<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reto página de documentación</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <div id="contenido" class="contenedor">
      <nav id="navbar">
        <header> <h1>Comandos básicos en Git: Índice </h1></header>
        <ul>
          <li>
            <a class="nav-link" href="http://">git init - inicializar una carpeta como un repositorio Git.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git clone - copiar un repositorio Git.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git add - agregar los contenidos de archivos al staging area.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://"
              >git status - estado de los archivos en el directorio de trabajo y en
              el staging area</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git diff - muestra diferencias entre el stage y lo modificado que
                no esta en el stage</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git commit - graba una instantánea del staging area.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git reset - deshace cambios y commits</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git rm - remueve archivos del staging area</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="http://">git stash - guardar cambios realizados en el stage y el index para
                confirmarlos más tarde</a>
          </li>
          <hr />
        </ul>
      </nav>
      <main id="main-doc">
        <section class="main-section">
          <header id="git_init"> <h2>Git init - inicializar una carpeta como un repositorio Git. </h2></header>
          <p>Para crear un repositorio en una carpeta existente de archivos, podes ejecutar el
            comando <span><b>git init</b></span>   en esa carpeta. Por ejemplo, digamos que tenemos una carpeta
            con algunos archivos adentro, así:</p>
          <pre>
<code>
  $cd repositorio_nuevo
  $ls
  README hello.rb
</code>            
</pre>
          <p>Se trata de un proyecto en el que estamos escribiendo ejemplos del “Hola Mundo”
            en todos los idiomas. Hasta el momento, sólo tenemos el código escrito en Ruby.
            Para iniciar el control de versión con Git, podemos ejecutar git init.</p>
<pre><code>
  $git init
  Initialized empty Git repository in /repositorio_nuevo/.git/
</code></pre>
<p>Ahora se puede ver que hay una subcarpeta oculta llamada “.git” en el proyecto.
  Este es tu repositorio donde se almacenan todos los cambios del proyecto. </p>
<pre><code>
  $ls -a 
  . .. .git README hello.rb
</code></pre>
  <p>
    En pocas palabras, se usa “git init” para convertir una carpeta existente en un
nuevo repositorio Git. Se puede hacer esto en cualquier carpeta en cualquier
momento.</p>
<ul>
  <li>Nota: Cuando se crea un repositorio con init, la primera vez que
    haces un push, tenes que correr <span><b>git push origin master</b></span>. Además
    hay que crear el branch master y hacerle un commit con los archivos
    agregados para que aparezca.
  </li>
</ul>
        </section>
        <section class="main-section">
          <header id="titulo_2"> <h2>Git clone - copiar un repositorio Git.</h2></header>
          <p>Si tienes que colaborar con alguien en un proyecto, o si deseas obtener una copia
            de un proyecto para poder ver o usar el código, debes clonarlo. Para lograrlo
            sólo tienes que ejecutar el comando <span><b>git clone [url]</b></span>  con la URL del proyecto que
            deseas copiar.</p>
<pre><code>
$git clone git://github.com/schacon/simplegit.git

Initialized empty Git repository in /private/tmp/simplegit/.git/
remote: Counting objects: 100, done.
remote: Compressing objects: 100% (86/86), done.
remote: Total 100 (delta 35), reused 0 (delta 0)
Receiving objects: 100% (100/100), 9.51 KiB, done.
Resolving deltas: 100% (35/35), done.

$cd simplegit/
$ls 
README Rakefile lib

</code></pre>
          <p>Esto copiará toda la historia de este proyecto, con lo cual lo tendrás a nivel local
            y te dará una carpeta de trabajo de la rama principal de ese proyecto para que
            puedas ver el código o empezar a editarlo. Si cambias a la nueva carpeta, podes
            ver la subcarpeta .git (ahí es donde están todos los datos del proyecto).</p>
<pre><code>
$ ls -a
. .. .git README Rakefile lib
$ cd .git
$ls 
HEAD description info packed-refs
branches hooks logs refs
config index objects
</code></pre>
<p>Por defecto, Git va a crear una carpeta que tiene el mismo nombre que el
  proyecto en la dirección que le indiques - básicamente cualquier cosa que
  aparezca después de la última barra de la URL. Si queres un nombre diferente,
  podes ponerlo al ﬁnal del comando, después de la URL. Entonces, se utiliza el
  comando git clone para obtener una copia local de un repositorio Git, para que
  puedas verlo y empezar a modiﬁcarlo. </p>        
        </section>
        <section class="main-section">
          <header><h2>git add - agregar los contenidos de archivos al staging area.</h2></header>
          <p>En Git tenes que agregar previamente los cambios realizados al staging area
            para luego poder hacer el commit correspondiente (conﬁrmar los cambios). Si
            el archivo que estás agregando es nuevo, entonces tenes que correr el comando
            <span><b>git add</b></span> para añadirlo inicialmente en tu staging area. Si el archivo ya está en
            “seguimiento” también tenes que correr el mismo comando (<span><b>git add</b></span>), no para
            agregar el archivo, sino para agregar las nuevas modiﬁcaciones en tu staging area.
            Volviendo al ejemplo de Hola Mundo, una vez iniciado el proyecto, empezaremos
            a agregarle archivos y para ello correremos el comando git add. Podemos usar
            el comando git status para ver en que estado está nuestro proyecto.</p>
<pre><code>
  $ git status -s
  ?? README
  ?? hello.rb
</code></pre>
          <p>El estado ‘AM’ signiﬁca que el archivo fue modiﬁcado en el disco desde que lo
            agregamos. Esto signiﬁca que si hacemos un commit de nuestro cambios hasta
            este momento, estaríamos grabando la versión del archivo que teníamos en el
            momento que corrimos git add, no la versión que está en nuestro disco. Git no
            asume que lo que uno quiere subir es explícitamente lo que tenemos en el disco,
            uno le tiene que avisar a Git con el comando git add nuevamente.</p>
          <p> 
            En pocas palabras, uno corre git add en un archivo cuando quiere incluir
            cualquier cambio que le hayas hecho a tu próximo commit. Cualquier cambio
            que no hayas agregado con este comando, no será incluído en el commit,
            esta particularidad nos ofrece la posibilidad de armar los commits de una forma
            más certera, con un alto nivel de detalle acerca de qué queremos incluir y qué
            no.
          </p>
        </section>
        <section class="main-section">
          <header> <h2>git status - estado de los archivos en el directorio de trabajo y en
            el staging area.</h2></header>
          <p>Tal como lo mencionamos en la sección anterior, uno puede usar este comando
            para ver el estado de su staging area comparado con el código que se encuentra en
            su directorio de trabajo. Usando la opción “-s” nos mostrará la forma abreviada
            del informe, en cambio si no usamos esa opción, nos mostrará más información
            del contexto. Aquí hay un ejemplo del resultado con y sin la opción:
          </p>
<pre><code>
$ git status -s
AM README
A hello.rb
Sin la opción se vería algo así:
$ git status -s
$ git status
# On branch master
# Initial commit
# Changes to be committed:
# (use "git rm --cached file..." to unstage)
# new file: README
# new file: hello.rb
# Changed but not updated:
# (use "git add &ltfile&gt ..." to update what will be committed)
# (use "git checkout -- &ltfile&gt..." to discard changes in working directory)
# modified: README
</code></pre>
          <p>Se ve que la salida corta es más compacta, pero la salida larga tiene algunos
            datos útiles que nos pueden llegar a servir en algún momento. Git además te
            informará de los archivos que fueron borrados, agregados o modiﬁcados desde
            tu último commit.</p>
<pre><code>
$ git status -s
M README
D hello.rb
</code></pre>
<p>En el siguiente ejemplo se pueden ver dos columnas, la primera es para el staging
  area, la segunda es para el directorio de trabajo. Entonces, por ejemplo si tienes
  el README file en el stage y después lo modificas nuevamente sin correr <span><b>“git add”</b></span> nuevamente, vas a ver algo así: </p>
<pre><code>
$ git status -s
MM README
D hello.rb
</code></pre>
        </section>
        <section class="main-section">
          <header><h2>git diff muestra diferencias entre el stage y lo modificado que
            no esta en el stage.</h2></header>
            <p>Hay dos usos diferentes para el comando git diff. El uso que veremos a continuación lo vamos a usar para describir los cambios que están en stage o que
              fueron modificados pero no están en el stage.</p>
              <ul><li>
                <h3>git diff - muestra las diferencias de cambios que no están en el stage.</h3>
          <p>Sin ningún argumento adicional, un simple <span><b>git diff</b></span> mostrará en formato unificado, qué código o contenido ha cambiado en el proyecto desde el último commit,
            que todavía no se metió en el stage area (no se le hizo el add) para el próximo
            commit.</p>
<pre><code>
$ vim hello.rb
$ git status -s
M hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index d62ac43..8d15d50 100644
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
class HelloWorld
def self.hello
-
puts "hello world"
#indica que se reemplazó esta línea por la de abajo. (- por +)
+
puts "hola mundo"
end
end
</code></pre>
          <p> Entonces, <span><b>“git diff”</b></span> te muestra cuáles son los cambios, línea por línea. Por lo
            general es un buen comando de seguimiento de <span><b>git status</b></span>.</p></li>
          <li>
            <h3><span><b>git diff HEAD</b></span> - muestra las diferencias de todos los cambios, estén
              o no en el staging.</h3>
              <p>
                Este comando nos permite básicamente ver la diferencia
entre nuestro directorio de trabajo y el último commit, ignorando el staging area.
Si hacemos un nuevo cambio en nuestro archivo hello.rb, entonces tendremos
algunos cambios en el directorio de trabajo y otros en el último commit, si
hacemos un <span><b>“diff HEAD”</b></span> entonces nos mostrará las diferencias entre lo último
subido y el directorio, sin tener en cuenta lo que está en el staging area.
              </p>
          </li>
          <li>
            <h3>
              git diff --stat - muestra una lista de cambios en lugar de un diff com-
pleto por archivo.
            </h3>
            <p>
              Si no queremos la salida completa del diff, pero queremos
              más que la salida del <span><b>git status</b></span>, podemos utilizar la opción - stat, lo que nos
              dará un resumen de los cambios en su lugar. Acá está el mismo ejemplo anterior,
              pero con la opción --stat.
            </p>
<pre><code>
$ git status -s
MM hello.rb
$ git diff --stat
hello.rb |
1 +
1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>
<p>
  También se puede proporcionar una ruta de archivo al final de cualquiera de
estas opciones para limitar la salida del diff a un archivo o subdirectorio.
</p>
          </li>
          </ul>
        </section>
        <section class="main-section">
          <header><h2>git commit - graba una instantánea del staging area.</h2></header>
          <p>Una vez que agregaste los cambios al staging area, vas a necesitar confirmar
            esos cambios con el comando add, pero para poder hacerlo git necesita grabar
            tus datos personales para poder hacer un seguimiento de los cambios. Entonces,
            el primer paso es configurar estos datos:</p>
<pre><code>
$ git config --global user.name 'Tu nombre'
$ git config --global user.email tumail@algundominio.com
</code></pre>
          <p>A continuación vamos a meter en el stage los cambios y luego a confirmarlos, en
            este ejemplo se usa la opción -m para agregar el mensaje al mismo tiempo que
            confirmamos los cambios:</p>
<pre><code>
$ git add hello.rb
$ git status -s
M hello.rb
$ git commit -m 'mis cambios al archivo hola mundo'
[master 68aa034] my hola mundo changes
1 files changed, 2 insertions(+), 1 deletions(-)
</code></pre>
<p>
  Ahora ya grabamos la instantánea del archivo. Si corremos el comando <span><b>git status</b></span> nuevamente, veremos que tenemos nuevamente un directorio de trabajo
“limpio”, lo que significa que no hicimos ningún cambio desde nuestro último
commit.
</p>
<pre><code>
$ git status
# On branch master nothing to commit (working directory clean)
</code></pre>
<p>
  Si no ingresamos la opción -m git va a intentar abrir un editor de texto para
que escribas el mensaje. Algo como esto:
</p>
<pre><code>
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
# modified:
hello.rb
#
~
~
".git/COMMIT_EDITMSG" 9L, 257C
</code></pre>
<p>
En este punto se agrega el mensaje de cambios en la parte superior del docu-
mento. Todas las líneas que comienzan con ‘#’ se ignoran. En general, es muy
importante escribir un buen mensaje de confirmación.
</p>
        </section>
        <section class="main-section">
          <header>git reset - deshace cambios y commits</header>
          <p>p1</p>
          <p>p2</p>
          <code></code>
        </section>
        <section class="main-section">
          <header>git rm - remueve archivos del staging area.</header>
          <p>p1</p>
          <p>p2</p>
          <code></code>
          <li></li>
        </section>
        <section class="main-section">
          <header>git stash - guardar cambios realizados en el stage y el index para
            confirmarlos más tarde.</header>
          <p>p1</p>
          <p>p2</p>
          <code></code>
          <li></li>
        </section>
      </main>
    </div>
  </body>
</html>

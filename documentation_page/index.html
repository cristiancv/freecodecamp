<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Reto página de documentación</title>
    <link rel="stylesheet" href="./styles.css" />
  </head>

  <body>
    <div id="contenido" class="contenedor">
      <nav id="navbar">
        <header> <h1>Comandos básicos en Git: Índice </h1></header>
        <ul>
          <li>
            <a class="nav-link" href="#git_init">git init - inicializar una carpeta como un repositorio Git.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_clone">git clone - copiar un repositorio Git.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_add">git add - agregar los contenidos de archivos al staging area.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_status"
              >git status - estado de los archivos en el directorio de trabajo y en
              el staging area</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_diff">git diff - muestra diferencias entre el stage y lo modificado que
                no esta en el stage</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_commit">git commit - graba una instantánea del staging area.</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_reset">git reset - deshace cambios y commits</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_rm">git rm - remueve archivos del staging area</a>
          </li>
          <hr />
          <li>
            <a class="nav-link" href="#git_stash">git stash - guardar cambios realizados en el stage y el index para
                confirmarlos más tarde</a>
          </li>
          <hr />
        </ul>
      </nav>
      <main id="main-doc">
        <section class="main-section">
          <header> <h2 id="git_init">Git init - inicializar una carpeta como un repositorio Git. </h2></header>
          <p>Para crear un repositorio en una carpeta existente de archivos, podes ejecutar el
            comando <span><b>git init</b></span>   en esa carpeta. Por ejemplo, digamos que tenemos una carpeta
            con algunos archivos adentro, así:</p>
<pre><code>$cd repositorio_nuevo
$ls
README hello.rb
</code></pre>
          <p>Se trata de un proyecto en el que estamos escribiendo ejemplos del “Hola Mundo”
            en todos los idiomas. Hasta el momento, sólo tenemos el código escrito en Ruby.
            Para iniciar el control de versión con Git, podemos ejecutar git init.</p>
<pre><code>$git init
Initialized empty Git repository in /repositorio_nuevo/.git/</code></pre>
<p>Ahora se puede ver que hay una subcarpeta oculta llamada “.git” en el proyecto.
  Este es tu repositorio donde se almacenan todos los cambios del proyecto. </p>
<pre><code>$ls -a 
. .. .git README hello.rb
</code></pre>
  <p>
    En pocas palabras, se usa “git init” para convertir una carpeta existente en un
nuevo repositorio Git. Se puede hacer esto en cualquier carpeta en cualquier
momento.</p>
<ul>
  <li>Nota: Cuando se crea un repositorio con init, la primera vez que
    haces un push, tenes que correr <span><b>git push origin master</b></span>. Además
    hay que crear el branch master y hacerle un commit con los archivos
    agregados para que aparezca.
  </li>
</ul>
        </section>
        <section class="main-section">
          <header> <h2 id="git_clone">Git clone - copiar un repositorio Git.</h2></header>
          <p>Si tienes que colaborar con alguien en un proyecto, o si deseas obtener una copia
            de un proyecto para poder ver o usar el código, debes clonarlo. Para lograrlo
            sólo tienes que ejecutar el comando <span><b>git clone [url]</b></span>  con la URL del proyecto que
            deseas copiar.</p>
<pre><code>$git clone git://github.com/schacon/simplegit.git

Initialized empty Git repository in /private/tmp/simplegit/.git/
remote: Counting objects: 100, done.
remote: Compressing objects: 100% (86/86), done.
remote: Total 100 (delta 35), reused 0 (delta 0)
Receiving objects: 100% (100/100), 9.51 KiB, done.
Resolving deltas: 100% (35/35), done.

$cd simplegit/
$ls 
README Rakefile lib</code></pre>
          <p>Esto copiará toda la historia de este proyecto, con lo cual lo tendrás a nivel local
            y te dará una carpeta de trabajo de la rama principal de ese proyecto para que
            puedas ver el código o empezar a editarlo. Si cambias a la nueva carpeta, podes
            ver la subcarpeta .git (ahí es donde están todos los datos del proyecto).</p>
<pre><code>
$ ls -a
. .. .git README Rakefile lib
$ cd .git
$ls 
HEAD description info packed-refs
branches hooks logs refs
config index objects
</code></pre>
<p>Por defecto, Git va a crear una carpeta que tiene el mismo nombre que el
  proyecto en la dirección que le indiques - básicamente cualquier cosa que
  aparezca después de la última barra de la URL. Si queres un nombre diferente,
  podes ponerlo al ﬁnal del comando, después de la URL. Entonces, se utiliza el
  comando git clone para obtener una copia local de un repositorio Git, para que
  puedas verlo y empezar a modiﬁcarlo. </p>        
        </section>
        <section class="main-section">
          <header><h2 id="git_add">git add - agregar los contenidos de archivos al staging area.</h2></header>
          <p>En Git tenes que agregar previamente los cambios realizados al staging area
            para luego poder hacer el commit correspondiente (conﬁrmar los cambios). Si
            el archivo que estás agregando es nuevo, entonces tenes que correr el comando
            <span><b>git add</b></span> para añadirlo inicialmente en tu staging area. Si el archivo ya está en
            “seguimiento” también tenes que correr el mismo comando (<span><b>git add</b></span>), no para
            agregar el archivo, sino para agregar las nuevas modiﬁcaciones en tu staging area.
            Volviendo al ejemplo de Hola Mundo, una vez iniciado el proyecto, empezaremos
            a agregarle archivos y para ello correremos el comando git add. Podemos usar
            el comando git status para ver en que estado está nuestro proyecto.</p>
<pre><code>
  $ git status -s
  ?? README
  ?? hello.rb
</code></pre>
          <p>El estado ‘AM’ signiﬁca que el archivo fue modiﬁcado en el disco desde que lo
            agregamos. Esto signiﬁca que si hacemos un commit de nuestro cambios hasta
            este momento, estaríamos grabando la versión del archivo que teníamos en el
            momento que corrimos git add, no la versión que está en nuestro disco. Git no
            asume que lo que uno quiere subir es explícitamente lo que tenemos en el disco,
            uno le tiene que avisar a Git con el comando git add nuevamente.</p>
          <p> 
            En pocas palabras, uno corre git add en un archivo cuando quiere incluir
            cualquier cambio que le hayas hecho a tu próximo commit. Cualquier cambio
            que no hayas agregado con este comando, no será incluído en el commit,
            esta particularidad nos ofrece la posibilidad de armar los commits de una forma
            más certera, con un alto nivel de detalle acerca de qué queremos incluir y qué
            no.
          </p>
        </section>
        <section class="main-section">
          <header> <h2 id="git_status">git status - estado de los archivos en el directorio de trabajo y en
            el staging area.</h2></header>
          <p>Tal como lo mencionamos en la sección anterior, uno puede usar este comando
            para ver el estado de su staging area comparado con el código que se encuentra en
            su directorio de trabajo. Usando la opción “-s” nos mostrará la forma abreviada
            del informe, en cambio si no usamos esa opción, nos mostrará más información
            del contexto. Aquí hay un ejemplo del resultado con y sin la opción:
          </p>
<pre><code>
$ git status -s
AM README
A hello.rb
Sin la opción se vería algo así:
$ git status -s
$ git status
# On branch master
# Initial commit
# Changes to be committed:
# (use "git rm --cached file..." to unstage)
# new file: README
# new file: hello.rb
# Changed but not updated:
# (use "git add &ltfile&gt ..." to update what will be committed)
# (use "git checkout -- &ltfile&gt..." to discard changes in working directory)
# modified: README
</code></pre>
          <p>Se ve que la salida corta es más compacta, pero la salida larga tiene algunos
            datos útiles que nos pueden llegar a servir en algún momento. Git además te
            informará de los archivos que fueron borrados, agregados o modiﬁcados desde
            tu último commit.</p>
<pre><code>
$ git status -s
M README
D hello.rb
</code></pre>
<p>En el siguiente ejemplo se pueden ver dos columnas, la primera es para el staging
  area, la segunda es para el directorio de trabajo. Entonces, por ejemplo si tienes
  el README file en el stage y después lo modificas nuevamente sin correr <span><b>“git add”</b></span> nuevamente, vas a ver algo así: </p>
<pre><code>
$ git status -s
MM README
D hello.rb
</code></pre>
        </section>
        <section class="main-section">
          <header><h2 id="git_diff">git diff muestra diferencias entre el stage y lo modificado que
            no esta en el stage.</h2></header>
            <p>Hay dos usos diferentes para el comando git diff. El uso que veremos a continuación lo vamos a usar para describir los cambios que están en stage o que
              fueron modificados pero no están en el stage.</p>
              <ul><li>
                <h3>git diff - muestra las diferencias de cambios que no están en el stage.</h3>
          <p>Sin ningún argumento adicional, un simple <span><b>git diff</b></span> mostrará en formato unificado, qué código o contenido ha cambiado en el proyecto desde el último commit,
            que todavía no se metió en el stage area (no se le hizo el add) para el próximo
            commit.</p>
<pre><code>
$ vim hello.rb
$ git status -s
M hello.rb
$ git diff
diff --git a/hello.rb b/hello.rb
index d62ac43..8d15d50 100644
--- a/hello.rb
+++ b/hello.rb
@@ -1,7 +1,7 @@
class HelloWorld
def self.hello
-
puts "hello world"
#indica que se reemplazó esta línea por la de abajo. (- por +)
+
puts "hola mundo"
end
end
</code></pre>
          <p> Entonces, <span><b>“git diff”</b></span> te muestra cuáles son los cambios, línea por línea. Por lo
            general es un buen comando de seguimiento de <span><b>git status</b></span>.</p></li>
          <li>
            <h3><span><b>git diff HEAD</b></span> - muestra las diferencias de todos los cambios, estén
              o no en el staging.</h3>
              <p>
                Este comando nos permite básicamente ver la diferencia
entre nuestro directorio de trabajo y el último commit, ignorando el staging area.
Si hacemos un nuevo cambio en nuestro archivo hello.rb, entonces tendremos
algunos cambios en el directorio de trabajo y otros en el último commit, si
hacemos un <span><b>“diff HEAD”</b></span> entonces nos mostrará las diferencias entre lo último
subido y el directorio, sin tener en cuenta lo que está en el staging area.
              </p>
          </li>
          <li>
            <h3>
              git diff --stat - muestra una lista de cambios en lugar de un diff com-
pleto por archivo.
            </h3>
            <p>
              Si no queremos la salida completa del diff, pero queremos
              más que la salida del <span><b>git status</b></span>, podemos utilizar la opción - stat, lo que nos
              dará un resumen de los cambios en su lugar. Acá está el mismo ejemplo anterior,
              pero con la opción --stat.
            </p>
<pre><code>
$ git status -s
MM hello.rb
$ git diff --stat
hello.rb |
1 +
1 files changed, 1 insertions(+), 0 deletions(-)
</code></pre>
<p>
  También se puede proporcionar una ruta de archivo al final de cualquiera de
estas opciones para limitar la salida del diff a un archivo o subdirectorio.
</p>
          </li>
          </ul>
        </section>
        <section class="main-section">
          <header><h2 id="git_commit">git commit - graba una instantánea del staging area.</h2></header>
          <p>Una vez que agregaste los cambios al staging area, vas a necesitar confirmar
            esos cambios con el comando add, pero para poder hacerlo git necesita grabar
            tus datos personales para poder hacer un seguimiento de los cambios. Entonces,
            el primer paso es configurar estos datos:</p>
<pre><code>
$ git config --global user.name 'Tu nombre'
$ git config --global user.email tumail@algundominio.com
</code></pre>
          <p>A continuación vamos a meter en el stage los cambios y luego a confirmarlos, en
            este ejemplo se usa la opción -m para agregar el mensaje al mismo tiempo que
            confirmamos los cambios:</p>
<pre><code>
$ git add hello.rb
$ git status -s
M hello.rb
$ git commit -m 'mis cambios al archivo hola mundo'
[master 68aa034] my hola mundo changes
1 files changed, 2 insertions(+), 1 deletions(-)
</code></pre>
<p>
  Ahora ya grabamos la instantánea del archivo. Si corremos el comando <span><b>git status</b></span> nuevamente, veremos que tenemos nuevamente un directorio de trabajo
“limpio”, lo que significa que no hicimos ningún cambio desde nuestro último
commit.
</p>
<pre><code>
$ git status
# On branch master nothing to commit (working directory clean)
</code></pre>
<p>
  Si no ingresamos la opción -m git va a intentar abrir un editor de texto para
que escribas el mensaje. Algo como esto:
</p>
<pre><code>
# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# Changes to be committed:
#
(use "git reset HEAD <file>..." to unstage)
#
# modified:
hello.rb
#
~
~
".git/COMMIT_EDITMSG" 9L, 257C
</code></pre>
<p>
En este punto se agrega el mensaje de cambios en la parte superior del docu-
mento. Todas las líneas que comienzan con ‘#’ se ignoran. En general, es muy
importante escribir un buen mensaje de confirmación.
</p>
<ul>
  <li>
    <h3><span><b>git commit -a</b></span>  - agrega automáticamente en el staging area los cam-
      bios de archivos que están en seguimiento</h3>
      <p>
Si te parece que correr el comando git add cada vez que modificas un archivo es demasiado engorroso,
Git te permite saltar esta parte con la opción -a. Esto le dice a Git, que ejecute
el git add en cualquier archivo que ya esta en “seguimiento” - es decir, cualquier
archivo que se encontraba en tu último commit y después fue modificado. Esto
te permite hacer un flujo de trabajo más al estilo de Subversion, sólo tenés que
editar los archivos y luego ejecutar git commit -a cuando queres que todo lo que
ha cambiado entre en el commit. Igualmente siempre tenes que ejecutar git add
para iniciar el seguimiento de nuevos archivos.
      </p>
<pre><code>
  $ vim hello.rb
  $ git status -s
  M hello.rb
  $ git commit -m 'cambios en el archivo hola'
  # On branch master
  # Changed but not updated:
  #(use "git add &ltfile&gt..." to update what will be committed)
  #(use "git checkout -- &ltfile&gt..." to discard changes in working directory)
  #
  # modified: hello.rb
  #
  no changes added to commit (use "git add" and/or "git commit -a")
  $ git commit -am 'changes to hello file'
  [master 78b2670] changes to hello file
  1 files changed, 2 insertions(+), 1 deletions(-)
</code></pre>
<p>
Este comando te permite cerrar el workflow de trabajo con git: haces cambios
a tu archivos, después usas <span><b>git add</b></span>  para meter esos cambios en el staging area,
con <span><b>git status</b></span>  y <span><b>git diff</b></span>  consultas las diferencias y los cambios y finalmente con
 <span><b>git commit</b></span> guardas una instantánea con el estado del conjunto de archivos en
ese momento determinado.
</p>
  </li>
</ul>
        </section>
        <section class="main-section">
          <header><h2 id="git_reset">  git reset - deshace cambios y commits.</h2></header>
          <p>Este es probablemente el comando más confuso, pero puede ser muy útil cuando
            cometas algún error.</p>
          <ul>
            <li>
              <h3>git reset HEAD - deshacer el último commit y sacar del staging area
los archivos modiﬁcados.</h3>
<p>
En general, se usa para sacar algo que agregaste al staging area (le hiciste el add) por accidente. Si ya hiciste el commit o sólo si lo agregaste, entonces este comando te ayuda a deshacer el commit (en
caso de que lo hayas hecho) y a sacar del índice a los archivos que le indiques. Supongamos que modiﬁcaste dos archivos, y queres grabarlos en dos commits
diferentes, entonces tenes que agregar y conﬁrmar uno y después agregar y conﬁrmar el otro. Si accidentalmente agregas los dos al mismo tiempo, ¿Cómo
sacas uno? Lo haces con <span><b>git reset HEAD -- nombreArchivo</b></span>. Técnicamente no es necesario añadir el -- pero se usa para avisarle a Git que terminaste de listar las
opciones y empiezas a enumerar las rutas de los archivos. Veamos un ejemplo, en el que tenemos dos archivos que fueron modiﬁcados desde el último commit,
vamos a hacer un commit con ambos y luego sacaremos uno de los dos:
</p>
<pre><code>
  $ git status -s
   M README
   M hello.rb
  $ git add .
  $ git status -s
  M README
  M hello.rb
  $ git reset HEAD -- hello.rb
  Unstaged changes after reset:
  M hello.rb
  $ git status -s
  M README
   M hello.rb
</code></pre>
<p>
  Ahora sí, puedes correr <span><b>git commit</b></span>  para grabar los cambios al archivo README,
no al archivo hello.rb. En caso de que te preguntes que está haciendo, lo que
hace en realidad es resetear las entradas del archivo ese en el “index” para que
sea igual que en el commit anterior.
</p>
<p>
  Si queres cambiar el nombre del comando porque te resulta más fácil de entender,
sólo tenes que grabarle un alias: <span><b>git conﬁg --global alias.unstage “reset HEAD”</b></span> .
</p>
<p>
  Una vez que corras eso, podes correr <span><b>git unstage [ﬁle]</b></span>. Cuando corres <span><b>git reset</b></span> 
sin especiﬁcar una opción, por defecto es --mixed. Las otras opciones son --soft
y --hard.
</p></li>
<li>
  <h3>git reset --soft - deshacer el último commit (no saca del los archivos
    del staging).</h3>
    <p>
      Lo primero que git reset hace es deshacer el último commit y
poner los archivos de nuevo en el índice. Si se incluye la opción –soft HEAD~
se puede deshacer el commit y los archivos modiﬁcados estarán de vuelta en el
stage.
    </p>
    <pre>
      <code>
        $ git status -s
        M hello.rb
        $ git commit -am 'hello with a flower'
        [master 5857ac1] hello with a flower
        1 files changed, 3 insertions(+), 1 deletions(-)
        $ git status
        # On branch master
        nothing to commit (working directory clean)
        $ git reset --soft HEAD~
        $ git status -s
        M hello.rb 
      </code>
    </pre>
    <p>
      Esto es, básicamente, hacer lo mismo que <span><b>git commit --amend</b></span>, que te permite
hacer más cambios y meterlos en el mismo último commit.
    </p>
    <ul>
      <li>
        <p>
          <strong>Nota:</strong> Nunca hagas un amend de un commit al que ya le hiciste el
push, porque puede traer problemas.
        </p>
      </li>
    </ul>
</li>
<li>
  <h3>git reset --hard - deshace el último commit, saca del stage los cambios y
    pisa los cambios del directorio de trabajo </h3>
    <p>Esta es la opción más peligrosa,
      ya que si lo corres por error perdes los cambios que venías realizando en tu directorio de trabajo.</p>
<pre><code>
$ git status
# On branch master
# Changes to be committed:
# (use "git reset HEAD <file>..." to unstage)
# modified: README
# Changes not staged for commit:
# (use "git add &ltfile&gt..." to update what will be committed)
# (use "git checkout -- &ltfile&gt..." to discard changes in working directory)
# modified: README
$ git reset --hard HEAD
HEAD is now at 5857ac1 hello with a flower
$ git status
# On branch master nothing to commit (working directory clean)
</code></pre>
<p>
  En el ejemplo anterior, teníamos los cambios para meterlos en el stage y luego
hacer el commit, pero un <span><b>git reset --hard</b></span> los pisó. Además de eso, el último
commit se ha deshecho. Se puede reemplazar HEAD con un el número de un
commit (SHA-1) u otra referencia para restablecer el directorio de trabajo a ese
punto especíﬁco.
</p>
    </li>
          </ul>
            <p>p2</p>
          <code></code>
        </section>
        <section class="main-section">
          <header><h2 id="git_rm">git rm - remueve archivos del staging area.</h2></header>
          <p>Esto es un poco diferente a <span><b>git reset HEAD</b></span> que saca los archivos del stage.
            Sacarlo del stage signiﬁca revertir el staging area a la versión anterior a que empecemos
            a modiﬁcar archivos en el directorio de trabajo. En cambio el comando
            <span><b>git rm</b></span> saca la entrada del archivo en el index, de manera que no va a ser tenido
            más en cuenta para el próximo commit.</p>
          <p>Por defecto, <span><b>git rm [ﬁlename]</b></span> va a remover el archivo del index y del disco, para
            sacarlo del index pero dejarlo en el directorio de trabajo hay que agregar la
            opción --cached.</p>
          <code></code>
          <li></li>
        </section>
        <section class="main-section">
          <header> <h2 id="git_stash">git stash - guardar cambios realizados en el stage y el index para
            confirmarlos más tarde.</h2></header>
          <p>Si estás en medio de algunos cambios y de repente aparece un bug urgente que
            no podes dejar de atender, pero no podes hacer un commit con algo que no anda
            y tampoco quieres perder los cambios, entonces este comando es la solución.</p>
          <p>p2</p>
          <ul>
            <li>
              <h3>git stash - agrega los cambios actuales a la pila</h3>
              <p> 
Este comando agarra todos los cambios del directorio de trabajo y del index y los pone en una lista
para poder buscarlos posteriormente. Después de correrlo te deja un directorio
de trabajo limpio y te devuelve al estado del último commit realizado.
              </p>
<pre><code>
$ git status -s
M hello.rb
$ git stash
Saved working directory and index state WIP on master: 5857ac1 hello with a flower
HEAD is now at 5857ac1 hello with a flower
$ git status
# On branch master
nothing to commit (working directory clean)
</code></pre>
            </li>
            <li>
              <h3> <span><b>git stash list</b></span> - ver los stash que están en la lista</h3>
              <p>
Al correr este comando nos devolverá una lista con los stashes realizados.
              </p>
<pre><code>
  $ git stash list
  stash@{0}: WIP on master: 5857ac1 hello with a flower
</code></pre>
<p>
  El último ítem agregado en el stash será referenciado por stash@{0} e incremen-
tará a los que estén en una unidad.
</p>
<pre><code>
$ vim hello.rb
$ git commit -am 'it stops raining'
[master ee2d2c6] it stops raining
1 files changed, 1 insertions(+), 1 deletions(-)
$ vim hello.rb
$ git stash
Saved working directory and index state WIP on master: ee2d2c6 it stops raining
HEAD is now at ee2d2c6 it stops raining
$ git stash list
stash@{0}: WIP on master: ee2d2c6 it stops raining
stash@{1}: WIP on master: 5857ac1 hello with a flower
</code></pre>
            </li>
            <li>
              <h3>git stash apply - toma un ítem de la lista de stashes y lo aplica al
                directorio de trabajo.</h3>
                <p>
                  Cuando estés listo para continuar desde donde dejaste,
ejecuta el comando git stash para traer de vuelta los cambios guardados en el
directorio de trabajo.
                </p>
<pre>
  <code>
    $ git stash apply
    # On branch master
    # Changes not staged for commit:
    # (use "git add &ltfile&gt..." to update what will be committed)
    # (use "git checkout -- &ltfile&gt..." to discard changes in working directory)
    #
    # modified:  hello.rb
    # no changes added to commit (use "git add" and/or "git commit -a")    
  </code>
</pre>
<p>
Si además queres borrar de la lista el ítem que tomaste, debes ejecutar <span><b>git stash pop</b></span>. 
</p>
            </li>
            <li>
              <h3>git stash drop - remueve un ítem de la lista de stashes</h3>
              <p>
                Si corres el
comando sin ningún parámetro entonces removerá el último stash, en cambio
podes especificar un ítem particular de la lista. En el siguiente ejemplo, se borra
el anterior al último:
              </p>
<pre><code>
$ git stash drop stash@{1}
Dropped stash@{1} (0b1478540189f30fef9804684673907c65865d8f)
</code></pre>
<p>
  Si queres borrar toda la lista entonces debes ejecutar el comando <span><b>git stash clear</b></span>.
</p>
            </li>
          </ul>
          <code></code>
          <li></li>
        </section>
      </main>
    </div>
  </body>
</html>
